#!/usr/bin/env python3
__author__ = 'Bruno Fosso'
__version__ = "1.0"

from librs.return_time import return_time
import os
import argparse
import sys
import argcomplete
from gzip import open as gzopen


def input_options():
    parser = argparse.ArgumentParser(description="split fasta and tsv files", prefix_chars="-")
    parser.add_argument("-m", "--mapping", type=str,
                        help="mapping file generated by 2_create_mapping_ENA_ITSoneDB_acc.py",
                        action="store", required=True)
    parser.add_argument("-f", "--fasta_file", type=str,
                        help="file containing all the ITS1 fasta sequences",
                        action="store", required=True)
    parser.add_argument("-n", "--ncbi_taxonomy_folder", type=str,
                        help="path to ncbi taxonomy folder",
                        action="store", required=True)
    parser.add_argument("-o", "--output_folder", type=str, help="output folder", action="store", required=False,
                        default=os.getcwd())
    argcomplete.autocomplete(parser)
    return parser.parse_args()


# noinspection PyPep8Naming
def fasta_parsing(its1_tsv):
    HMM_seq = set()
    ENA_seq = set()
    common = set()
    with open(its1_tsv, 'rt') as tab:
        tab.readline()
        for line in tab:
            field = list(map(str.strip, line.split("\t")))
            if field[2] != "Null" and field[6] == "Null":
                ENA_seq.add(field[2])
            elif field[2] == "Null" and field[6] != "Null":
                HMM_seq.add(field[6])
            elif field[2] != "Null" and field[6] != "Null":
                common.add(field[6])
    return ENA_seq, HMM_seq, common


def generazione_dizionari_tassonomia(taxnomy_folder):
    if os.path.exists(os.path.join(taxnomy_folder, "nodes.dmp")):
        nodesfile = open(os.path.join(taxnomy_folder, "nodes.dmp"))
    else:
        sys.exit("No NODESFILE")
    if os.path.exists(os.path.join(taxnomy_folder, "names.dmp")):
        namesfile = open(os.path.join(taxnomy_folder, "names.dmp"))
    else:
        sys.exit("no namesfile")

    parent_dict = {}
    for linea in nodesfile:
        linea = linea.strip()
        fields = list(map(str.strip, linea.split("|")))
        nodeid, parentid = fields[0], fields[1]
        parent_dict[nodeid] = parentid

    name_dict = {}
    for line in namesfile:
        line = line.strip()
        fields = list(map(str.strip, line.split("|")))
        if fields[3] == "scientific name":
            nodeid, name = fields[0], fields[1]
            name_dict[nodeid] = name
    return parent_dict, name_dict


def accession(identifier):
    parts = identifier.split(".")
    return parts[0]


def find_taxa(fasta):
    global s
    taxa_dir = {}
    acc2data = {}
    with gzopen(fasta, 'rt') as aa:
        for line in aa:
            if line.startswith(">"):
                s = list(map(str.strip, line.split("|")))
                taxa_dir[s[0][1:]] = s[1]
                acc2data.setdefault(s[0][1:], "")
                acc2data[s[0][1:]] += line
            else:
                acc2data[s[0][1:]] += line
    return taxa_dir, acc2data


if __name__ == "__main__":
    param = input_options()
    its1, fasta_its1, ncbi_taxonomy, out = param.mapping, param.fasta_file, param.ncbi_taxonomy_folder, param.output_folder
    node2parent, node2name = generazione_dizionari_tassonomia(ncbi_taxonomy)
    acc2node, fasta_data = find_taxa(fasta_its1)
    ENA_acc, HMM_acc, common_acc = fasta_parsing(its1)
    # return_time("acc2node %s" % len(acc2node))
    return_time("""------------------------
    ENA accession %s 
    HMM accession %s
    Common accession %s""" % (len(ENA_acc), len(HMM_acc), len(common_acc)))

    euk_child = set()
    for node, parent in node2parent.items():
        if parent == "2759":
            euk_child.add(node)

    acc2group = {}

    for acc, node in acc2node.items():
        parent = node2parent[node]
        path = set()
        while node != parent:
            path.add(node)
            node = parent
            parent = node2parent[node]
        # print path
        # print path.intersection(euk_child)
        if len(path.intersection(euk_child)) != 0:
            group_id = list(path.intersection(euk_child))[0]
            # se gruppo opistokonta e fungi nel path
            # node2name fungi
            if group_id == "33154" and "4751" in path:
                acc2group[acc] = node2name["4751"]
            # se gruppo opistokonta e metazoa nel path
            # node2name metazoa
            elif group_id == "33154" and "33208" in path:
                acc2group[acc] = node2name["33208"]
            # se gruppo opistokonta no fungi no metazoa nel path
            # node2name other_Opisthokonta
            elif group_id == "33154" and "4751" not in path and "33208" not in path:
                acc2group[acc] = "other_Opisthokonta"
            else:
                acc2group[acc] = node2name[group_id]
        else:
            print(acc, list(path)[0], node2name[list(path)[0]])
    # return_time("acc2group %s" % len(acc2group))
    # FASTA_STATICI created by (2) script in main
    only_ENA = gzopen(os.path.join(out, "ITSoneDB_ITS1_ENA.fa.gz"), "wt")
    only_HMM = gzopen(os.path.join(out, "ITSoneDB_ITS1_HMM.fa.gz"), "wt")
    both = gzopen(os.path.join(out, "ITSoneDB_ITS1_ENAandHMM.fa.gz"), "wt")

    for acc, node in acc2node.items():
        # print(acc)
        if acc in acc2group:
            groupname = acc2group[acc].replace(' ', '_')
            if acc in common_acc:
                both.write("%s" % fasta_data[acc])
                if os.path.exists(os.path.join(out, "%s_ITSoneDB_ITS1_ENAandHMM.fa.gz" % groupname)):
                    with gzopen(os.path.join(out, "%s_ITSoneDB_ITS1_ENAandHMM.fa.gz" % groupname), "at") as a:
                        a.write("%s" % fasta_data[acc])
                else:
                    a = gzopen(os.path.join(out, "%s_ITSoneDB_ITS1_ENAandHMM.fa.gz" % groupname), "wt")
                    a.write("%s" % fasta_data[acc])
            elif acc in ENA_acc:
                only_ENA.write("%s" % fasta_data[acc])
                if os.path.exists(os.path.join(out, "%s_ITSoneDB_ITS1_ENA.fa.gz" % groupname)):
                    with gzopen(os.path.join(out, "%s_ITSoneDB_ITS1_ENA.fa.gz" % groupname), "at") as a:
                        a.write("%s" % fasta_data[acc])
                else:
                    a = gzopen(os.path.join(out, "%s_ITSoneDB_ITS1_ENA.fa.gz" % groupname), "wt")
                    a.write("%s" % fasta_data[acc])
            elif acc in HMM_acc:
                only_HMM.write("%s" % fasta_data[acc])
                if os.path.exists(os.path.join(out, "%s_ITSoneDB_ITS1_HMM.fa.gz" % groupname)):
                    with gzopen(os.path.join(out, "%s_ITSoneDB_ITS1_HMM.fa.gz" % groupname), "at") as a:
                        a.write("%s" % fasta_data[acc])
                else:
                    a = gzopen(os.path.join(out, "%s_ITSoneDB_ITS1_HMM.fa.gz" % groupname), "wt")
                    a.write("%s" % fasta_data[acc])
    only_ENA.close()
    only_HMM.close()
    both.close()
    return_time('DONE')

    # solo_rep = open( os.path.join( out, "ITSoneDB_rep_seq.fasta" ), "w" )
    # rep_with_flan = open( os.path.join( out, "ITSoneDB_rep_seq_and_flanking.fasta" ), "w" )
    # for acc in rep_list:
    #     s = acc.split("_")
    #     node = acc2taxa[s[0]]
    #     if s[-1] == "HMM":
    #         seq_hmm = seq_index[s[0]][int( float( acc2_HMM_loc[s[0]][0] ) ):int( float( acc2_HMM_loc[s[0]][1] ) )]
    #         solo_rep.write( ">%s_ITS1_HMM|%s|%s|ITS1 located by HMM annotation, %ibp\n" % (s[0], node2name[node], node, len( seq_hmm )) )
    #         solo_rep.write( "%s\n" % seq_hmm )
    #         if (float(acc2_HMM_loc[s[0]][0]) - 150) < 0:
    #             start = 0
    #         else: start =  float(acc2_HMM_loc[s[0]][0]) - 150
    #         if (float(acc2_HMM_loc[s[0]][1]) + 150) > len(seq_index[s[0]]):
    #             end = len(seq_index[s[0]])
    #         else: end = float(acc2_HMM_loc[s[0]][1]) + 150
    #         print acc, start, end
    #         seq_hmm = seq_index[s[0]][int( float( start ) ):int( float( end ) )]
    #         rep_with_flan.write( ">%s_ITS1_HMM|%s|%s|ITS1 located by HMM annotation, %ibp\n" % (s[0], node2name[node], node, len( seq_hmm )) )
    #         rep_with_flan.write( "%s\n" % seq_hmm )
    #     elif s[-1] == "ENA":
    #         seq_gb = seq_index[s[0]][int( float( acc2_GB_loc[s[0]][0] ) ):int( float( acc2_GB_loc[s[0]][1] ) )]
    #         solo_rep.write( ">%s_ITS1_ENA|%s|%s|ITS1 located by ENA annotation, %ibp\n" % (s[0], node2name[node], node, len( seq_gb )) )
    #         solo_rep.write( "%s\n" % seq_gb )
    #         if (float(acc2_GB_loc[s[0]][0]) - 150) < 0:
    #             start = 0
    #         else: start = float(acc2_GB_loc[s[0]][0]) -150
    #         if float(acc2_GB_loc[s[0]][1]) + 150 > len(seq_index[s[0]]):
    #             end = len(seq_index[s[0]])
    #         else: end = float(acc2_GB_loc[s[0]][1]) + 150
    #         print acc, start, end
    #         seq_gb = seq_index[s[0]][int( float( start ) ):int( float( end ) )]
    #         rep_with_flan.write( ">%s_ITS1_HMM|%s|%s|ITS1 located by HMM annotation, %ibp\n" % (s[0], node2name[node], node, len( seq_gb )) )
    #         rep_with_flan.write( "%s\n" % seq_gb )
    # solo_rep.close()
    # rep_with_flan.close()
